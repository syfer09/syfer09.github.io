---
layout: default
title: Chapter 18
date: 2025-08-07 16:00:00 +0000
categories: jekyll update
permalink: /learningc18
---
# Chapter 18
# Exercises
## E18.1
### Statement
For each of the following declarations, identify the storage class, type qualifiers, type specifiers, declarators, and initializers.

(a)`static char **lookup(int level);`

(b) `volatile unsigned long io_flags;`

(c) `extern char *file_name[MAX_FILES], path[];`

(d) `static const char token_buf[] = "";`

### Solution
|Storage class|Type qualifiers|Type specifier|Declarators|Initializers|
|-|-|-|-|-|
|`static`|none|`char **`|`lookup(int level)`|none|
|none|`volatile`|`unsigned long`| `io_flags`|none|
|`extern`|none|`char * []`|`file_name, path`|none|
|`static`|`const`|`char []`| `token_buf` | `""`|

## E18.2
### Statement
Answer each of the following questions with `auto`, `extern`, `register`, and/or `static`.

(a) Which storage class is used primarily to indicate that a variable or function can be shared by several files?

(b) Suppose that a variable `x` is to be shared by several functions in one file but hidden from functions in other files. Which storage class should `x` be declared to have?

(c) Which storage classes can affect the storage duration of a variable?

### Solution
(a) `extern`

(b) `static`

(c) `extern` and `static`

## E18.3
### Statement
List the storage duration (static or automatic), scope (block or file), and linkage (internal, external, or none) of each variable and parameter in the following file:

```
extern float a;

void f(register double b) {
    static int c;
    auto char d;
}
```

### Solution

|Variable|Storage duration|Scope|Linkage|
|-|-|-|-|
|`a`|automatic|file|external|
|`b`|automatic|block|none|
|`c`|static|block|none|
|`d`|automatic|block|none|

## E18.4
### Statement
Let `f` be the following function. What will be the value of `f(10)` if `f` has never been called before? What will be the value of `f(10)` if `f` has been called five times previously?

```
int f(int i) {
    static int j = 0;
    return i * j++;
}
```

### Solution
To start, `f(10)` will be 0, since `j = 0`. After calling `f` five times, `f(10)` will be `10 * 5 = 50`.

## E18.5
### Statement
State whether each of the following statements is true or false. Justify each answer.

(a) Every variable with static storage duration has file scope.

(b) Every variable declared inside a function has no linkage.

(c) Every variable with internal linkage has static storage duration.

(d) Every parameter has block scope.

### Solution
## E18.6
### Statement
The following function is supposed to print an error message. Each message is preceded by
an integer, indicating the number of times the function has been called. Unfortunately, the
function always displays 1 as the number of the error message. Locate the error and show
how to fix it without making any changes outside the function.

```
void print_error(const char *message)
{
    int n = 1 ;
    printf("Error %d: %s\n", n++, message);
}
```

### Solution
We have to declare `n` as `static` for its value to to be preserved after function calls.

## E18.7
### Statement
Suppose that we declare `x` to be a `const` object. Which one of the following statements about `x` is false?

(a) If `x` is of type `int`, it can be used as the value of a case label in a `switch` statement.

(b) The compiler will check that no assignment is made to `x`.

(c) `x` is subject to the same scope rules as variables.

(d) `x` can be of any type.

### Solution
(a) is false, one cannot use a constant variable inside a `switch` statement.
## E18.8
### Statement
Write a complete description of the type of `x` as specified by each of the following declarations.

(a) `char (*x[10])(int);`

(b) `int (*x(int))[5];`

(c) `float *(*x(void))(int);`

(d) `void (*x(int, void (*y)(int)))(int);`

### Solution
(a) array of 10 pointers to functions that require integers and return characters

(b) function which takes in integers and returns a pointer to an integer array of 5 elements

(c) function with no arguments that returns a pointer to a function that needs an integer and returns a float pointer.

(d) a function with an integer argument as well as an argument requiring a pointer to a function which requires an integer and returns a pointer to void. x has return type of a pointer to a function with an integer value and no return.

## E18.9
### Statement
Use a series of type definitions to simplify each of the declarations in Exercise 8.

### Solution
(a)

```
typedef char fcn(int);
typedef fcn(int) *fcn_ptr
typedef fcn_ptr fcn_ptr_array[10]
fcn_ptr_array x;
```
(b)

```
typedef int fcn[5]
typedef fcn fcn_ptr(int)
fcn_prt *x;
```

(c)

```
typedef float *fcn(int);
typdef fcn *inner_fcn(void);
inner_fcn x;
```

(d)

```
typedef void out(int);
typedef void *arg(int);
typedef out *inner(int, arg);
out x;
```

These are much more confusing than the actual definition, I really do not see what is "simpler" about them.

## E18.10
### Statement
Write declarations for the following variables and functions:

(a) `p` is a pointer to a function with a character pointer argument that returns a character pointer.

(b) `f` is a function with two arguments: `p`, a pointer to a structure with tag `t`, and `n`, a long
integer. `f` returns a pointer to a function that has no arguments and returns nothing.

(c) `a` is an array of four pointers to functions that have no arguments and return nothing.  The elements of a initially point to functions named `insert`, `search`, `update`, and `print`.

(d) `b` is an array of 10 pointers to functions with two `int` arguments that return structures with tag `t`.

### Solution
(a) `char *(*p)(char *);`

(b) `void *f(struct t *p, long n)(void);`

(c) `void (*a[4])(void) = {insert, search, update, print};`

(d) `struc t (*b[10])(int, int)`

I rest my case, these were so much simpler to write than `typedef`-ing anything.

## E18.11
### Statement
In Section 18.4, we saw that the following declarations are illegal:

```
int f(int)[]; /* functions can't return arrays */
int g(int)(int); /* functions can't return functions */
int a[10](int); /* array elements can't be functions */
```

We can, however, achieve similar effects by using pointers: a function can return a pointer to the first element in an array, a function can return a pointer to a function, and the elements of an array can be pointers to functions. Revise each of these declarations accordingly.

### Solution
```
int *f(int);
ing (*g(int))(int);
int (*a[10])(int);
```

## E18.12
### Statement
(a) Write a complete description of the type of the function `f`, assuming that it's declared as follows:

`int (*f(float (*)(long), char *))(double);`

(b) Give an example showing how `f` would be called.

### Solution
`f` is a function which takes two arguments, a pointer to a function which requires a long and returns a float, and a char pointer. `f` returns pointers to functions that require doubles and return integers.

(b) `int n = *(f(g, chrptr))(0.5)` where `g` is a function requiring a long and returning a float while `chrptr` is a `char` pointer

## E18.13
### Statement
Which of the following declarations are legal? (Assume that `PI` is a macro that represents 3.14159.)

(a) `char c = 65;`

(b) `static int i = 5, j = i * i;`

(c) `double d = 2 * PI;`

(d) `double angles[] = {0, PI / 2, PI, 3 * PI / 2};`

### Solution
(a) is legal

(b) is illegal because `static` requires constant expressions in initialization. `i * i` does not work.

(c) is legal

(d) is legal

## E18.14
### Statement
Which kind of variables cannot be initialized?

(a) Array variables

(b) Enumeration variables

(c) Structure variables

(d) Union variables

(e) None of the above

### Solution
(e) all variables can be initialized.

## E18.15
### Statement
Which property of a variable determines whether or not it has a default initial value?

(a) Storage duration

(b) Scope

(c) Linkage

(d) Type

### Solution
(a) storage duration, specifically `static` is the only type that initializes with a default initial value of 0.

# Conclusion

This was a fun one, I loved deciphering the complicated declarations. 

It was interesting to learn about the various scope defining keywords that C has. I'm assuming that they are the equivalent to `public` `protected` `private` version in other languages. 

In general, I find it really funny that we have "suggestions" in this chapter as well, where keywords such as `register` and `inline` could potentially be ignore by the compiler if it so chooses.

Short and sweet, I'll probably have to come back to this as a reference when I see some complicated identifier.
